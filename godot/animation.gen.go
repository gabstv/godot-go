package godot

import (
	"github.com/gabstv/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// AnimationInterpolationType is an enum for InterpolationType values.
type AnimationInterpolationType int

const (
	AnimationInterpolationCubic   AnimationInterpolationType = 2
	AnimationInterpolationLinear  AnimationInterpolationType = 1
	AnimationInterpolationNearest AnimationInterpolationType = 0
)

// AnimationTrackType is an enum for TrackType values.
type AnimationTrackType int

const (
	AnimationTypeAnimation AnimationTrackType = 5
	AnimationTypeAudio     AnimationTrackType = 4
	AnimationTypeBezier    AnimationTrackType = 3
	AnimationTypeMethod    AnimationTrackType = 2
	AnimationTypeTransform AnimationTrackType = 1
	AnimationTypeValue     AnimationTrackType = 0
)

// AnimationUpdateMode is an enum for UpdateMode values.
type AnimationUpdateMode int

const (
	AnimationUpdateCapture    AnimationUpdateMode = 3
	AnimationUpdateContinuous AnimationUpdateMode = 0
	AnimationUpdateDiscrete   AnimationUpdateMode = 1
	AnimationUpdateTrigger    AnimationUpdateMode = 2
)

//func NewAnimationFromPointer(ptr gdnative.Pointer) Animation {
func newAnimationFromPointer(ptr gdnative.Pointer) Animation {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Animation{}
	obj.SetBaseObject(owner)

	return obj
}

/*
An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track. [codeblock] # This creates an animation that makes the node "Enemy" move to the right by # 100 pixels in 0.5 seconds. var animation = Animation.new() var track_index = animation.add_track(Animation.TYPE_VALUE) animation.track_set_path(track_index, "Enemy:position:x") animation.track_insert_key(track_index, 0.0, 0) animation.track_insert_key(track_index, 0.5, 100) [/codeblock] Animations are just data containers, and must be added to nodes such as an [AnimationPlayer] to be played back. Animation tracks have different types, each with its own set of dedicated methods. Check [enum TrackType] to see available types.
*/
type Animation struct {
	Resource
	owner gdnative.Object
}

func (o *Animation) BaseClass() string {
	return "Animation"
}

/*
        Adds a track to the Animation.
	Args: [{ false type int} {-1 true at_position int}], Returns: int
*/
func (o *Animation) AddTrack(aType gdnative.Int, atPosition gdnative.Int) gdnative.Int {
	//log.Println("Calling Animation.AddTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(aType)
	ptrArguments[1] = gdnative.NewPointerFromInt(atPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "add_track")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the animation name at the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of an Animation Track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: String
*/
func (o *Animation) AnimationTrackGetKeyAnimation(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.String {
	//log.Println("Calling Animation.AnimationTrackGetKeyAnimation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "animation_track_get_key_animation")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Inserts a key with value [code]animation[/code] at the given [code]time[/code] (in seconds). The [code]track_idx[/code] must be the index of an Animation Track.
	Args: [{ false track_idx int} { false time float} { false animation String}], Returns: int
*/
func (o *Animation) AnimationTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, animation gdnative.String) gdnative.Int {
	//log.Println("Calling Animation.AnimationTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromString(animation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "animation_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Sets the key identified by [code]key_idx[/code] to value [code]animation[/code]. The [code]track_idx[/code] must be the index of an Animation Track.
	Args: [{ false track_idx int} { false key_idx int} { false animation String}], Returns: void
*/
func (o *Animation) AnimationTrackSetKeyAnimation(trackIdx gdnative.Int, keyIdx gdnative.Int, animation gdnative.String) {
	//log.Println("Calling Animation.AnimationTrackSetKeyAnimation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromString(animation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "animation_track_set_key_animation")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the end offset of the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of an Audio Track. End offset is the number of seconds cut off at the ending of the audio stream.
	Args: [{ false track_idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) AudioTrackGetKeyEndOffset(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.AudioTrackGetKeyEndOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_get_key_end_offset")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the start offset of the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of an Audio Track. Start offset is the number of seconds cut off at the beginning of the audio stream.
	Args: [{ false track_idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) AudioTrackGetKeyStartOffset(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.AudioTrackGetKeyStartOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_get_key_start_offset")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the audio stream of the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of an Audio Track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: Resource
*/
func (o *Animation) AudioTrackGetKeyStream(trackIdx gdnative.Int, keyIdx gdnative.Int) ResourceImplementer {
	//log.Println("Calling Animation.AudioTrackGetKeyStream()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_get_key_stream")

	// Call the parent method.
	// Resource
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newResourceFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ResourceImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Resource" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ResourceImplementer)
	}

	return &ret
}

/*
        Inserts an Audio Track key at the given [code]time[/code] in seconds. The [code]track_idx[/code] must be the index of an Audio Track. [code]stream[/code] is the [AudioStream] resource to play. [code]start_offset[/code] is the number of seconds cut off at the beginning of the audio stream, while [code]end_offset[/code] is at the ending.
	Args: [{ false track_idx int} { false time float} { false stream Resource} {0 true start_offset float} {0 true end_offset float}], Returns: int
*/
func (o *Animation) AudioTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, stream ResourceImplementer, startOffset gdnative.Real, endOffset gdnative.Real) gdnative.Int {
	//log.Println("Calling Animation.AudioTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromObject(stream.GetBaseObject())
	ptrArguments[3] = gdnative.NewPointerFromReal(startOffset)
	ptrArguments[4] = gdnative.NewPointerFromReal(endOffset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Sets the end offset of the key identified by [code]key_idx[/code] to value [code]offset[/code]. The [code]track_idx[/code] must be the index of an Audio Track.
	Args: [{ false track_idx int} { false key_idx int} { false offset float}], Returns: void
*/
func (o *Animation) AudioTrackSetKeyEndOffset(trackIdx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real) {
	//log.Println("Calling Animation.AudioTrackSetKeyEndOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_set_key_end_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the start offset of the key identified by [code]key_idx[/code] to value [code]offset[/code]. The [code]track_idx[/code] must be the index of an Audio Track.
	Args: [{ false track_idx int} { false key_idx int} { false offset float}], Returns: void
*/
func (o *Animation) AudioTrackSetKeyStartOffset(trackIdx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real) {
	//log.Println("Calling Animation.AudioTrackSetKeyStartOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_set_key_start_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the stream of the key identified by [code]key_idx[/code] to value [code]offset[/code]. The [code]track_idx[/code] must be the index of an Audio Track.
	Args: [{ false track_idx int} { false key_idx int} { false stream Resource}], Returns: void
*/
func (o *Animation) AudioTrackSetKeyStream(trackIdx gdnative.Int, keyIdx gdnative.Int, stream ResourceImplementer) {
	//log.Println("Calling Animation.AudioTrackSetKeyStream()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromObject(stream.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_set_key_stream")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the in handle of the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: Vector2
*/
func (o *Animation) BezierTrackGetKeyInHandle(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Animation.BezierTrackGetKeyInHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_get_key_in_handle")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the out handle of the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: Vector2
*/
func (o *Animation) BezierTrackGetKeyOutHandle(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Animation.BezierTrackGetKeyOutHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_get_key_out_handle")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the value of the key identified by [code]key_idx[/code]. The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) BezierTrackGetKeyValue(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.BezierTrackGetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_get_key_value")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Inserts a Bezier Track key at the given [code]time[/code] in seconds. The [code]track_idx[/code] must be the index of a Bezier Track. [code]in_handle[/code] is the left-side weight of the added Bezier curve point, [code]out_handle[/code] is the right-side one, while [code]value[/code] is the actual value at this point.
	Args: [{ false track_idx int} { false time float} { false value float} {(0, 0) true in_handle Vector2} {(0, 0) true out_handle Vector2}], Returns: int
*/
func (o *Animation) BezierTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, value gdnative.Real, inHandle gdnative.Vector2, outHandle gdnative.Vector2) gdnative.Int {
	//log.Println("Calling Animation.BezierTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromReal(value)
	ptrArguments[3] = gdnative.NewPointerFromVector2(inHandle)
	ptrArguments[4] = gdnative.NewPointerFromVector2(outHandle)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the interpolated value at the given [code]time[/code] (in seconds). The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false time float}], Returns: float
*/
func (o *Animation) BezierTrackInterpolate(trackIdx gdnative.Int, time gdnative.Real) gdnative.Real {
	//log.Println("Calling Animation.BezierTrackInterpolate()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_interpolate")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Sets the in handle of the key identified by [code]key_idx[/code] to value [code]in_handle[/code]. The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false key_idx int} { false in_handle Vector2}], Returns: void
*/
func (o *Animation) BezierTrackSetKeyInHandle(trackIdx gdnative.Int, keyIdx gdnative.Int, inHandle gdnative.Vector2) {
	//log.Println("Calling Animation.BezierTrackSetKeyInHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromVector2(inHandle)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_set_key_in_handle")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the out handle of the key identified by [code]key_idx[/code] to value [code]out_handle[/code]. The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false key_idx int} { false out_handle Vector2}], Returns: void
*/
func (o *Animation) BezierTrackSetKeyOutHandle(trackIdx gdnative.Int, keyIdx gdnative.Int, outHandle gdnative.Vector2) {
	//log.Println("Calling Animation.BezierTrackSetKeyOutHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromVector2(outHandle)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_set_key_out_handle")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the value of the key identified by [code]key_idx[/code] to the given value. The [code]track_idx[/code] must be the index of a Bezier Track.
	Args: [{ false track_idx int} { false key_idx int} { false value float}], Returns: void
*/
func (o *Animation) BezierTrackSetKeyValue(trackIdx gdnative.Int, keyIdx gdnative.Int, value gdnative.Real) {
	//log.Println("Calling Animation.BezierTrackSetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_set_key_value")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clear the animation (clear all tracks and reset all).
	Args: [], Returns: void
*/
func (o *Animation) Clear() {
	//log.Println("Calling Animation.Clear()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "clear")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Adds a new track that is a copy of the given track from [code]to_animation[/code].
	Args: [{ false track_idx int} { false to_animation Animation}], Returns: void
*/
func (o *Animation) CopyTrack(trackIdx gdnative.Int, toAnimation AnimationImplementer) {
	//log.Println("Calling Animation.CopyTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromObject(toAnimation.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "copy_track")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the index of the specified track. If the track is not found, return -1.
	Args: [{ false path NodePath}], Returns: int
*/
func (o *Animation) FindTrack(path gdnative.NodePath) gdnative.Int {
	//log.Println("Calling Animation.FindTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(path)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "find_track")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Animation) GetLength() gdnative.Real {
	//log.Println("Calling Animation.GetLength()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "get_length")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Animation) GetStep() gdnative.Real {
	//log.Println("Calling Animation.GetStep()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "get_step")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the amount of tracks in the animation.
	Args: [], Returns: int
*/
func (o *Animation) GetTrackCount() gdnative.Int {
	//log.Println("Calling Animation.GetTrackCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "get_track_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Animation) HasLoop() gdnative.Bool {
	//log.Println("Calling Animation.HasLoop()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "has_loop")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns all the key indices of a method track, given a position and delta time.
	Args: [{ false track_idx int} { false time_sec float} { false delta float}], Returns: PoolIntArray
*/
func (o *Animation) MethodTrackGetKeyIndices(trackIdx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray {
	//log.Println("Calling Animation.MethodTrackGetKeyIndices()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(timeSec)
	ptrArguments[2] = gdnative.NewPointerFromReal(delta)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "method_track_get_key_indices")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Returns the method name of a method track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: String
*/
func (o *Animation) MethodTrackGetName(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.String {
	//log.Println("Calling Animation.MethodTrackGetName()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "method_track_get_name")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Returns the arguments values to be called on a method track for a given key in a given track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: Array
*/
func (o *Animation) MethodTrackGetParams(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Array {
	//log.Println("Calling Animation.MethodTrackGetParams()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "method_track_get_params")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Removes a track by specifying the track index.
	Args: [{ false track_idx int}], Returns: void
*/
func (o *Animation) RemoveTrack(trackIdx gdnative.Int) {
	//log.Println("Calling Animation.RemoveTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "remove_track")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false time_sec float}], Returns: void
*/
func (o *Animation) SetLength(timeSec gdnative.Real) {
	//log.Println("Calling Animation.SetLength()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(timeSec)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "set_length")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enabled bool}], Returns: void
*/
func (o *Animation) SetLoop(enabled gdnative.Bool) {
	//log.Println("Calling Animation.SetLoop()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "set_loop")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size_sec float}], Returns: void
*/
func (o *Animation) SetStep(sizeSec gdnative.Real) {
	//log.Println("Calling Animation.SetStep()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(sizeSec)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "set_step")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Finds the key index by time in a given track. Optionally, only find it if the exact time is given.
	Args: [{ false track_idx int} { false time float} {False true exact bool}], Returns: int
*/
func (o *Animation) TrackFindKey(trackIdx gdnative.Int, time gdnative.Real, exact gdnative.Bool) gdnative.Int {
	//log.Println("Calling Animation.TrackFindKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromBool(exact)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_find_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the track at [code]idx[/code] wraps the interpolation loop. New tracks wrap the interpolation loop by default.
	Args: [{ false track_idx int}], Returns: bool
*/
func (o *Animation) TrackGetInterpolationLoopWrap(trackIdx gdnative.Int) gdnative.Bool {
	//log.Println("Calling Animation.TrackGetInterpolationLoopWrap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_interpolation_loop_wrap")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the interpolation type of a given track.
	Args: [{ false track_idx int}], Returns: enum.Animation::InterpolationType
*/
func (o *Animation) TrackGetInterpolationType(trackIdx gdnative.Int) AnimationInterpolationType {
	//log.Println("Calling Animation.TrackGetInterpolationType()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_interpolation_type")

	// Call the parent method.
	// enum.Animation::InterpolationType
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return AnimationInterpolationType(ret)
}

/*
        Returns the amount of keys in a given track.
	Args: [{ false track_idx int}], Returns: int
*/
func (o *Animation) TrackGetKeyCount(trackIdx gdnative.Int) gdnative.Int {
	//log.Println("Calling Animation.TrackGetKeyCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the time at which the key is located.
	Args: [{ false track_idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) TrackGetKeyTime(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.TrackGetKeyTime()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_time")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the transition curve (easing) for a specific key (see the built-in math function [method @GDScript.ease]).
	Args: [{ false track_idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) TrackGetKeyTransition(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.TrackGetKeyTransition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_transition")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the value of a given key in a given track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: Variant
*/
func (o *Animation) TrackGetKeyValue(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Variant {
	//log.Println("Calling Animation.TrackGetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_value")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Gets the path of a track. For more information on the path format, see [method track_set_path].
	Args: [{ false track_idx int}], Returns: NodePath
*/
func (o *Animation) TrackGetPath(trackIdx gdnative.Int) gdnative.NodePath {
	//log.Println("Calling Animation.TrackGetPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_path")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Gets the type of a track.
	Args: [{ false track_idx int}], Returns: enum.Animation::TrackType
*/
func (o *Animation) TrackGetType(trackIdx gdnative.Int) AnimationTrackType {
	//log.Println("Calling Animation.TrackGetType()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_type")

	// Call the parent method.
	// enum.Animation::TrackType
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return AnimationTrackType(ret)
}

/*
        Insert a generic key in a given track.
	Args: [{ false track_idx int} { false time float} { false key Variant} {1 true transition float}], Returns: void
*/
func (o *Animation) TrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, key gdnative.Variant, transition gdnative.Real) {
	//log.Println("Calling Animation.TrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromVariant(key)
	ptrArguments[3] = gdnative.NewPointerFromReal(transition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_insert_key")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns [code]true[/code] if the track at index [code]idx[/code] is enabled.
	Args: [{ false track_idx int}], Returns: bool
*/
func (o *Animation) TrackIsEnabled(trackIdx gdnative.Int) gdnative.Bool {
	//log.Println("Calling Animation.TrackIsEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_is_enabled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given track is imported. Else, return [code]false[/code].
	Args: [{ false track_idx int}], Returns: bool
*/
func (o *Animation) TrackIsImported(trackIdx gdnative.Int) gdnative.Bool {
	//log.Println("Calling Animation.TrackIsImported()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_is_imported")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Moves a track down.
	Args: [{ false track_idx int}], Returns: void
*/
func (o *Animation) TrackMoveDown(trackIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackMoveDown()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_move_down")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Changes the index position of track [code]idx[/code] to the one defined in [code]to_idx[/code].
	Args: [{ false track_idx int} { false to_idx int}], Returns: void
*/
func (o *Animation) TrackMoveTo(trackIdx gdnative.Int, toIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackMoveTo()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(toIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_move_to")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Moves a track up.
	Args: [{ false track_idx int}], Returns: void
*/
func (o *Animation) TrackMoveUp(trackIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackMoveUp()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_move_up")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Removes a key by index in a given track.
	Args: [{ false track_idx int} { false key_idx int}], Returns: void
*/
func (o *Animation) TrackRemoveKey(trackIdx gdnative.Int, keyIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackRemoveKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_remove_key")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Removes a key by position (seconds) in a given track.
	Args: [{ false track_idx int} { false position float}], Returns: void
*/
func (o *Animation) TrackRemoveKeyAtPosition(trackIdx gdnative.Int, position gdnative.Real) {
	//log.Println("Calling Animation.TrackRemoveKeyAtPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_remove_key_at_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Enables/disables the given track. Tracks are enabled by default.
	Args: [{ false track_idx int} { false enabled bool}], Returns: void
*/
func (o *Animation) TrackSetEnabled(trackIdx gdnative.Int, enabled gdnative.Bool) {
	//log.Println("Calling Animation.TrackSetEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_enabled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given track as imported or not.
	Args: [{ false track_idx int} { false imported bool}], Returns: void
*/
func (o *Animation) TrackSetImported(trackIdx gdnative.Int, imported gdnative.Bool) {
	//log.Println("Calling Animation.TrackSetImported()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromBool(imported)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_imported")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        If [code]true[/code], the track at [code]idx[/code] wraps the interpolation loop.
	Args: [{ false track_idx int} { false interpolation bool}], Returns: void
*/
func (o *Animation) TrackSetInterpolationLoopWrap(trackIdx gdnative.Int, interpolation gdnative.Bool) {
	//log.Println("Calling Animation.TrackSetInterpolationLoopWrap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromBool(interpolation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_interpolation_loop_wrap")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the interpolation type of a given track.
	Args: [{ false track_idx int} { false interpolation int}], Returns: void
*/
func (o *Animation) TrackSetInterpolationType(trackIdx gdnative.Int, interpolation gdnative.Int) {
	//log.Println("Calling Animation.TrackSetInterpolationType()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(interpolation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_interpolation_type")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the time of an existing key.
	Args: [{ false track_idx int} { false key_idx int} { false time float}], Returns: void
*/
func (o *Animation) TrackSetKeyTime(trackIdx gdnative.Int, keyIdx gdnative.Int, time gdnative.Real) {
	//log.Println("Calling Animation.TrackSetKeyTime()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(time)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_key_time")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the transition curve (easing) for a specific key (see the built-in math function [method @GDScript.ease]).
	Args: [{ false track_idx int} { false key_idx int} { false transition float}], Returns: void
*/
func (o *Animation) TrackSetKeyTransition(trackIdx gdnative.Int, keyIdx gdnative.Int, transition gdnative.Real) {
	//log.Println("Calling Animation.TrackSetKeyTransition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(transition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_key_transition")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the value of an existing key.
	Args: [{ false track_idx int} { false key int} { false value Variant}], Returns: void
*/
func (o *Animation) TrackSetKeyValue(trackIdx gdnative.Int, key gdnative.Int, value gdnative.Variant) {
	//log.Println("Calling Animation.TrackSetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(key)
	ptrArguments[2] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_key_value")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the path of a track. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by [code]":"[/code]. For example, [code]"character/skeleton:ankle"[/code] or [code]"character/mesh:transform/local"[/code].
	Args: [{ false track_idx int} { false path NodePath}], Returns: void
*/
func (o *Animation) TrackSetPath(trackIdx gdnative.Int, path gdnative.NodePath) {
	//log.Println("Calling Animation.TrackSetPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromNodePath(path)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_path")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Swaps the track [code]idx[/code]'s index position with the track [code]with_idx[/code].
	Args: [{ false track_idx int} { false with_idx int}], Returns: void
*/
func (o *Animation) TrackSwap(trackIdx gdnative.Int, withIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackSwap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(withIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_swap")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Insert a transform key for a transform track.
	Args: [{ false track_idx int} { false time float} { false location Vector3} { false rotation Quat} { false scale Vector3}], Returns: int
*/
func (o *Animation) TransformTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, location gdnative.Vector3, rotation gdnative.Quat, scale gdnative.Vector3) gdnative.Int {
	//log.Println("Calling Animation.TransformTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromVector3(location)
	ptrArguments[3] = gdnative.NewPointerFromQuat(rotation)
	ptrArguments[4] = gdnative.NewPointerFromVector3(scale)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "transform_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the interpolated value of a transform track at a given time (in seconds). An array consisting of 3 elements: position ([Vector3]), rotation ([Quat]) and scale ([Vector3]).
	Args: [{ false track_idx int} { false time_sec float}], Returns: Array
*/
func (o *Animation) TransformTrackInterpolate(trackIdx gdnative.Int, timeSec gdnative.Real) gdnative.Array {
	//log.Println("Calling Animation.TransformTrackInterpolate()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(timeSec)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "transform_track_interpolate")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns all the key indices of a value track, given a position and delta time.
	Args: [{ false track_idx int} { false time_sec float} { false delta float}], Returns: PoolIntArray
*/
func (o *Animation) ValueTrackGetKeyIndices(trackIdx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray {
	//log.Println("Calling Animation.ValueTrackGetKeyIndices()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromReal(timeSec)
	ptrArguments[2] = gdnative.NewPointerFromReal(delta)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "value_track_get_key_indices")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Returns the update mode of a value track.
	Args: [{ false track_idx int}], Returns: enum.Animation::UpdateMode
*/
func (o *Animation) ValueTrackGetUpdateMode(trackIdx gdnative.Int) AnimationUpdateMode {
	//log.Println("Calling Animation.ValueTrackGetUpdateMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "value_track_get_update_mode")

	// Call the parent method.
	// enum.Animation::UpdateMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return AnimationUpdateMode(ret)
}

/*
        Sets the update mode (see [enum UpdateMode]) of a value track.
	Args: [{ false track_idx int} { false mode int}], Returns: void
*/
func (o *Animation) ValueTrackSetUpdateMode(trackIdx gdnative.Int, mode gdnative.Int) {
	//log.Println("Calling Animation.ValueTrackSetUpdateMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(trackIdx)
	ptrArguments[1] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "value_track_set_update_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// AnimationImplementer is an interface that implements the methods
// of the Animation class.
type AnimationImplementer interface {
	ResourceImplementer
	AddTrack(aType gdnative.Int, atPosition gdnative.Int) gdnative.Int
	AnimationTrackGetKeyAnimation(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.String
	AnimationTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, animation gdnative.String) gdnative.Int
	AnimationTrackSetKeyAnimation(trackIdx gdnative.Int, keyIdx gdnative.Int, animation gdnative.String)
	AudioTrackGetKeyEndOffset(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	AudioTrackGetKeyStartOffset(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	AudioTrackGetKeyStream(trackIdx gdnative.Int, keyIdx gdnative.Int) ResourceImplementer
	AudioTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, stream ResourceImplementer, startOffset gdnative.Real, endOffset gdnative.Real) gdnative.Int
	AudioTrackSetKeyEndOffset(trackIdx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real)
	AudioTrackSetKeyStartOffset(trackIdx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real)
	AudioTrackSetKeyStream(trackIdx gdnative.Int, keyIdx gdnative.Int, stream ResourceImplementer)
	BezierTrackGetKeyInHandle(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2
	BezierTrackGetKeyOutHandle(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2
	BezierTrackGetKeyValue(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	BezierTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, value gdnative.Real, inHandle gdnative.Vector2, outHandle gdnative.Vector2) gdnative.Int
	BezierTrackInterpolate(trackIdx gdnative.Int, time gdnative.Real) gdnative.Real
	BezierTrackSetKeyInHandle(trackIdx gdnative.Int, keyIdx gdnative.Int, inHandle gdnative.Vector2)
	BezierTrackSetKeyOutHandle(trackIdx gdnative.Int, keyIdx gdnative.Int, outHandle gdnative.Vector2)
	BezierTrackSetKeyValue(trackIdx gdnative.Int, keyIdx gdnative.Int, value gdnative.Real)
	Clear()
	CopyTrack(trackIdx gdnative.Int, toAnimation AnimationImplementer)
	FindTrack(path gdnative.NodePath) gdnative.Int
	GetLength() gdnative.Real
	GetStep() gdnative.Real
	GetTrackCount() gdnative.Int
	HasLoop() gdnative.Bool
	MethodTrackGetKeyIndices(trackIdx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray
	MethodTrackGetName(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.String
	MethodTrackGetParams(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Array
	RemoveTrack(trackIdx gdnative.Int)
	SetLength(timeSec gdnative.Real)
	SetLoop(enabled gdnative.Bool)
	SetStep(sizeSec gdnative.Real)
	TrackFindKey(trackIdx gdnative.Int, time gdnative.Real, exact gdnative.Bool) gdnative.Int
	TrackGetInterpolationLoopWrap(trackIdx gdnative.Int) gdnative.Bool
	TrackGetKeyCount(trackIdx gdnative.Int) gdnative.Int
	TrackGetKeyTime(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	TrackGetKeyTransition(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	TrackGetKeyValue(trackIdx gdnative.Int, keyIdx gdnative.Int) gdnative.Variant
	TrackGetPath(trackIdx gdnative.Int) gdnative.NodePath
	TrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, key gdnative.Variant, transition gdnative.Real)
	TrackIsEnabled(trackIdx gdnative.Int) gdnative.Bool
	TrackIsImported(trackIdx gdnative.Int) gdnative.Bool
	TrackMoveDown(trackIdx gdnative.Int)
	TrackMoveTo(trackIdx gdnative.Int, toIdx gdnative.Int)
	TrackMoveUp(trackIdx gdnative.Int)
	TrackRemoveKey(trackIdx gdnative.Int, keyIdx gdnative.Int)
	TrackRemoveKeyAtPosition(trackIdx gdnative.Int, position gdnative.Real)
	TrackSetEnabled(trackIdx gdnative.Int, enabled gdnative.Bool)
	TrackSetImported(trackIdx gdnative.Int, imported gdnative.Bool)
	TrackSetInterpolationLoopWrap(trackIdx gdnative.Int, interpolation gdnative.Bool)
	TrackSetInterpolationType(trackIdx gdnative.Int, interpolation gdnative.Int)
	TrackSetKeyTime(trackIdx gdnative.Int, keyIdx gdnative.Int, time gdnative.Real)
	TrackSetKeyTransition(trackIdx gdnative.Int, keyIdx gdnative.Int, transition gdnative.Real)
	TrackSetKeyValue(trackIdx gdnative.Int, key gdnative.Int, value gdnative.Variant)
	TrackSetPath(trackIdx gdnative.Int, path gdnative.NodePath)
	TrackSwap(trackIdx gdnative.Int, withIdx gdnative.Int)
	TransformTrackInsertKey(trackIdx gdnative.Int, time gdnative.Real, location gdnative.Vector3, rotation gdnative.Quat, scale gdnative.Vector3) gdnative.Int
	TransformTrackInterpolate(trackIdx gdnative.Int, timeSec gdnative.Real) gdnative.Array
	ValueTrackGetKeyIndices(trackIdx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray
	ValueTrackSetUpdateMode(trackIdx gdnative.Int, mode gdnative.Int)
}
