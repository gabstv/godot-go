package gdnative

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "types.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
#cgo CFLAGS: -I../cgodeps/godot-cpp/godot_headers
#include "gdnative.gen.h"
// #include <cgodeps/godot-cpp/godot_headers/gdnative/plane.h>
// Include all headers for now. TODO: Look up all the required
// headers we need to import based on the method arguments and return types.
#include <gdnative/aabb.h>
#include <gdnative/array.h>
#include <gdnative/basis.h>
#include <gdnative/color.h>
#include <gdnative/dictionary.h>
#include <gdnative/gdnative.h>
#include <gdnative/node_path.h>
#include <gdnative/plane.h>
#include <gdnative/pool_arrays.h>
#include <gdnative/quat.h>
#include <gdnative/rect2.h>
#include <gdnative/rid.h>
#include <gdnative/string.h>
#include <gdnative/string_name.h>
#include <gdnative/transform.h>
#include <gdnative/transform2d.h>
#include <gdnative/variant.h>
#include <gdnative/vector2.h>
#include <gdnative/vector3.h>
#include <gdnative_api_struct.gen.h>
*/
import "C"
import "unsafe"

// NewEmptyPlane will return a pointer to an empty
// initialized Plane. This is primarily used in
// conjunction with MethodBindPtrCall.
func NewEmptyPlane() Pointer {
	var obj C.godot_plane
	return Pointer{base: unsafe.Pointer(&obj)}
}

// NewPointerFromPlane will return an unsafe pointer to the given
// object. This is primarily used in conjunction with MethodBindPtrCall.
func NewPointerFromPlane(obj Plane) Pointer {
	return Pointer{base: unsafe.Pointer(obj.getBase())}
}

// NewPlaneFromPointer will return a Plane from the
// given unsafe pointer. This is primarily used in conjunction with MethodBindPtrCall.
func NewPlaneFromPointer(ptr Pointer) Plane {

	return Plane{base: (*C.godot_plane)(ptr.getBase())}
}

type Plane struct {
	base *C.godot_plane
}

func (gdt Plane) getBase() *C.godot_plane {
	return gdt.base
}

// NewPlaneWithReals godot_plane_new_with_reals [[godot_plane * r_dest] [const godot_real p_a] [const godot_real p_b] [const godot_real p_c] [const godot_real p_d]] void
func NewPlaneWithReals(a Real, b Real, c Real, d Real) Plane {
	var dest C.godot_plane
	arg1 := a.getBase()
	arg2 := b.getBase()
	arg3 := c.getBase()
	arg4 := d.getBase()
	C.go_godot_plane_new_with_reals(GDNative.api, &dest, arg1, arg2, arg3, arg4)
	return Plane{base: &dest}
}

// NewPlaneWithVectors godot_plane_new_with_vectors [[godot_plane * r_dest] [const godot_vector3 * p_v1] [const godot_vector3 * p_v2] [const godot_vector3 * p_v3]] void
func NewPlaneWithVectors(v1 Vector3, v2 Vector3, v3 Vector3) Plane {
	var dest C.godot_plane
	arg1 := v1.getBase()
	arg2 := v2.getBase()
	arg3 := v3.getBase()
	C.go_godot_plane_new_with_vectors(GDNative.api, &dest, arg1, arg2, arg3)
	return Plane{base: &dest}
}

// NewPlaneWithNormal godot_plane_new_with_normal [[godot_plane * r_dest] [const godot_vector3 * p_normal] [const godot_real p_d]] void
func NewPlaneWithNormal(normal Vector3, d Real) Plane {
	var dest C.godot_plane
	arg1 := normal.getBase()
	arg2 := d.getBase()
	C.go_godot_plane_new_with_normal(GDNative.api, &dest, arg1, arg2)
	return Plane{base: &dest}
}

// AsString godot_plane_as_string [[const godot_plane * p_self]] godot_string
func (gdt *Plane) AsString() String {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_as_string(GDNative.api, arg0)

	utfStr := C.go_godot_string_utf8(GDNative.api, &ret)
	char := C.go_godot_char_string_get_data(GDNative.api, &utfStr)
	goStr := C.GoString(char)
	C.go_godot_char_string_destroy(GDNative.api, &utfStr)

	return String(goStr)

}

// Normalized godot_plane_normalized [[const godot_plane * p_self]] godot_plane
func (gdt *Plane) Normalized() Plane {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_normalized(GDNative.api, arg0)

	return Plane{base: &ret}

}

// Center godot_plane_center [[const godot_plane * p_self]] godot_vector3
func (gdt *Plane) Center() Vector3 {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_center(GDNative.api, arg0)

	return Vector3{base: &ret}

}

// GetAnyPoint godot_plane_get_any_point [[const godot_plane * p_self]] godot_vector3
func (gdt *Plane) GetAnyPoint() Vector3 {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_get_any_point(GDNative.api, arg0)

	return Vector3{base: &ret}

}

// IsPointOver godot_plane_is_point_over [[const godot_plane * p_self] [const godot_vector3 * p_point]] godot_bool
func (gdt *Plane) IsPointOver(point Vector3) Bool {
	arg0 := gdt.getBase()
	arg1 := point.getBase()

	ret := C.go_godot_plane_is_point_over(GDNative.api, arg0, arg1)

	return Bool(ret)
}

// DistanceTo godot_plane_distance_to [[const godot_plane * p_self] [const godot_vector3 * p_point]] godot_real
func (gdt *Plane) DistanceTo(point Vector3) Real {
	arg0 := gdt.getBase()
	arg1 := point.getBase()

	ret := C.go_godot_plane_distance_to(GDNative.api, arg0, arg1)

	return Real(ret)
}

// HasPoint godot_plane_has_point [[const godot_plane * p_self] [const godot_vector3 * p_point] [const godot_real p_epsilon]] godot_bool
func (gdt *Plane) HasPoint(point Vector3, epsilon Real) Bool {
	arg0 := gdt.getBase()
	arg1 := point.getBase()
	arg2 := epsilon.getBase()

	ret := C.go_godot_plane_has_point(GDNative.api, arg0, arg1, arg2)

	return Bool(ret)
}

// Project godot_plane_project [[const godot_plane * p_self] [const godot_vector3 * p_point]] godot_vector3
func (gdt *Plane) Project(point Vector3) Vector3 {
	arg0 := gdt.getBase()
	arg1 := point.getBase()

	ret := C.go_godot_plane_project(GDNative.api, arg0, arg1)

	return Vector3{base: &ret}

}

// Intersect3 godot_plane_intersect_3 [[const godot_plane * p_self] [godot_vector3 * r_dest] [const godot_plane * p_b] [const godot_plane * p_c]] godot_bool
func (gdt *Plane) Intersect3(dest Vector3, b Plane, c Plane) Bool {
	arg0 := gdt.getBase()
	arg1 := dest.getBase()
	arg2 := b.getBase()
	arg3 := c.getBase()

	ret := C.go_godot_plane_intersect_3(GDNative.api, arg0, arg1, arg2, arg3)

	return Bool(ret)
}

// IntersectsRay godot_plane_intersects_ray [[const godot_plane * p_self] [godot_vector3 * r_dest] [const godot_vector3 * p_from] [const godot_vector3 * p_dir]] godot_bool
func (gdt *Plane) IntersectsRay(dest Vector3, from Vector3, dir Vector3) Bool {
	arg0 := gdt.getBase()
	arg1 := dest.getBase()
	arg2 := from.getBase()
	arg3 := dir.getBase()

	ret := C.go_godot_plane_intersects_ray(GDNative.api, arg0, arg1, arg2, arg3)

	return Bool(ret)
}

// IntersectsSegment godot_plane_intersects_segment [[const godot_plane * p_self] [godot_vector3 * r_dest] [const godot_vector3 * p_begin] [const godot_vector3 * p_end]] godot_bool
func (gdt *Plane) IntersectsSegment(dest Vector3, begin Vector3, end Vector3) Bool {
	arg0 := gdt.getBase()
	arg1 := dest.getBase()
	arg2 := begin.getBase()
	arg3 := end.getBase()

	ret := C.go_godot_plane_intersects_segment(GDNative.api, arg0, arg1, arg2, arg3)

	return Bool(ret)
}

// OperatorNeg godot_plane_operator_neg [[const godot_plane * p_self]] godot_plane
func (gdt *Plane) OperatorNeg() Plane {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_operator_neg(GDNative.api, arg0)

	return Plane{base: &ret}

}

// OperatorEqual godot_plane_operator_equal [[const godot_plane * p_self] [const godot_plane * p_b]] godot_bool
func (gdt *Plane) OperatorEqual(b Plane) Bool {
	arg0 := gdt.getBase()
	arg1 := b.getBase()

	ret := C.go_godot_plane_operator_equal(GDNative.api, arg0, arg1)

	return Bool(ret)
}

// SetNormal godot_plane_set_normal [[godot_plane * p_self] [const godot_vector3 * p_normal]] void
func (gdt *Plane) SetNormal(normal Vector3) {
	arg0 := gdt.getBase()
	arg1 := normal.getBase()

	C.go_godot_plane_set_normal(GDNative.api, arg0, arg1)
}

// GetNormal godot_plane_get_normal [[const godot_plane * p_self]] godot_vector3
func (gdt *Plane) GetNormal() Vector3 {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_get_normal(GDNative.api, arg0)

	return Vector3{base: &ret}

}

// GetD godot_plane_get_d [[const godot_plane * p_self]] godot_real
func (gdt *Plane) GetD() Real {
	arg0 := gdt.getBase()

	ret := C.go_godot_plane_get_d(GDNative.api, arg0)

	return Real(ret)
}

// SetD godot_plane_set_d [[godot_plane * p_self] [const godot_real p_d]] void
func (gdt *Plane) SetD(d Real) {
	arg0 := gdt.getBase()
	arg1 := d.getBase()

	C.go_godot_plane_set_d(GDNative.api, arg0, arg1)
}
